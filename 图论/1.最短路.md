单源最短路径问题（Single Source Shortest Path，SSSP 问题）是指给出一张有向图，求出起点 $1$ 到其他点的最短路径。
### 1. Dijkstra 算法
>DIjkstra 仅适用于所有边的长度都是非负数的图。
1. 初始化 $dist[1] = 0$，其余节点的 $dist$ 值为正无穷大。
2. 找出节点 $x$ 满足未被标记的、且 $dist[x]$ 最小的节点，对其进行标记。
3. 遍历节点 $x$ 的所有出边 $(x, y, z)$，若 $dist[y] > dist[x] + z$，则使用 $dist[x] + z$ 更新 $dist[y]$。
4. 重复上述步骤 $2、3$，直到所有的节点都被标记。

Dijkstra 算法基于贪心思想。下面是对其的证明。
为了表述的方便，我们采用以下符号：
* $set=\{a, b, c, ...\}$ // 已经确定最短路径的点的集合，最开始集合中仅有 $1$ 号点，算法结束的时候，集合中包含所有的点。
* $dist[u]$ // 从起点开始，经过 $set$ 中的点，到 $u$ 的最短路径。
* $short[u]$ // 从起点开始，到 $u$ 的全局最短路径。

我们将证明下面这个命题：算法进行到第 $k$ 步时，$set$ 中每个节点 $i$ 的 $dist$ 值等于其 $short$ 值。第 $n$ 步时算法结束，此时已经找到起点 $1$ 到所有点的最短路径。

$k = 1$ 时，$dist[s] = short[s] = 0$  (这里 $s$ 表示起点的意思)

假设第 $k$ 步成立，即集合 set 中所有点的 $dist$ 值即为其 $short$ 值。

设第 $k + 1$ 步我们选择了顶点 $v$ (未被标记的，$dist$ 值最小的点)。现在我们想证明存在着一条更短的路径从起点到达 $v$。

假设命题不成立，注意到我们已经尝试过所有的通过集合 set 中的点到达 v 的路径，所以此时 $dist[v]$ 的值即为通过集合 $set$ 中的点到达 $v$ 的最短路径。如果存在这更短的路径的话，那么一定是经过的集合外的点，记为 $y$。所以我们有$dist[y] + d[y, v] < dist[v]$。注意到 **边长非负**，所以 $d[y, v] \ge 0$。所以 $dist[y] < dist[v]$。这与 $v$ 是未选择未标记的，$dist$ 值最小的的节点矛盾。

所以第 $k + 1$ 步也成立，我们确定了节点 $v$ 的 $short$ 值。

证明结束。

从上面的证明也可得知，算法将进行 $n$ 步。即最开始的步骤中，步骤 $2、3$ 我们将重复 $n - 1$ 次。
```c++
void dijkstra() {
  memset(d, 0x3f, sizeof d); // dist 的值初始化为正无穷大
  memset(v, 0, sizeof v);    // 所有节点最开始均未被标记
  d[1] = 0                   // 将起点放入集合 set 中
  for (int i = 1; i < n; i++) {
    int x = 0;
    for (int j = 1; j <= n; j++) 
      if (!v[j] && (x == 0 || d[j] < d[x])) x = j;
    v[x] = 1; // 将 x 放入集合 set 中，此时 d[x] 的值即为其最短路径值，步骤 2 结束
    for (int y = 1; y <= n; y++) {
      if (!v[y]) d[y] = min(d[y], d[x] + a[x][y]);
    }
  }
}
```
时间复杂度 $O(n^2)$。
改用邻接表存边 + 二叉堆维护 ``dist`` 数组，可优化算法。
```c++
void dijkstra() {
  memset(d, 0x3f, sizeof d);
  memset(v, 0, sizeof v);
  d[1] = 0;
  q.push(make_pair(0, 1));
  while (q.size()) {
    // 取出堆顶
    int x = q.top().second; q.pop();
    if (v[x]) continue;
    v[x] = 1;
    for (int i = head[x]; i; i = Next[i]) {
      int y = ver[i], z = edge[i];
      if (d[y] > d[x] + z) {
        // 更新，把新的二元组插入堆
        d[y] = d[x] + z;
        q.push(make_pair(-d[y], y));
      }
    }
  }
}
``` 
时间复杂度：
while 循环最近进行 $n$ 次，每次获取 top 的时间复杂度最多为 $\log n$。扩展边最多进行 $m$ 次，每次时间复杂度 $\log n$。故最终时间复杂度为 $(m + n)\log n$。(此处存疑，堆中的元素为 $O(n)$ 的吗？)

### 2. 松弛操作
我们用 $d[x]$ 表示从起点 $s$ 到 $x$ 的最短路径估计值。对一条边 $(u, v)$ 的松弛过程为：将从节点 $s$ 到 节点 $u$ 之间的最短路径距离加上节点 $u$ 与 $v$ 之间的边权重，并与当前的 $s$ 到 $v$ 的最短路径估计进行比较，如果前者更小，则更新估计值。
#### 初始化操作
```c++
void INITIALIZE-SINGLE-SOURCE() {
  memset(d, 0x3f, sizeof d); // d 数组为保存距离估计值的数组，其初始值为无穷大，最终值为全局最短路值
  memset(pre, 0, sizeof pre); // pre 数组用来处理最短路径，即每个节点的前驱
  d[1] = 0; // 1 号节点为起点
}
```

#### 松弛操作
```c++
void RELAX(u, v) {
  if (d[v] > d[u] + e[u][v]) {
    d[v] = d[u] + e[u][v];
    pre[v] = u;
  }
} 

对于为什么叫 ``松弛`` 这个名字，大家可以想象一条皮筋连接了起点 $s$ 到 $v$ 经过的各个节点。当我们进行了上述操作以后，皮筋相对来说可能变得更松弛一些。

### 3. Bellman-Ford 算法
bool BELLMAN-FORD() {
  INITIALIZE-SINGLE-SOURCE();
  for (int i = 1; i < n; i++) {
    对于图 E 的每一条边 (u, v)
      RELAX(u, v);
  }
  对于图 E 的每一条边 (u, v)
    if (d[v] > d[u] + e[u][v]) 
      return false; // 表示存在负环
  return ture;
}
```
Bellman-Ford 算法基于 **路径松弛性质** ：设从源节点 $s$ 到节点 $v_k$ 的任意一条最短路径 $p=<v_0, v_1, \cdots, v_k>$。我们在对图进行初始化，并在这之后进行了一系统的边松弛操作，其中包括对边 $(v_0, v_1)$、$(v_1, v_2)$、$\cdots$、$(v_{k-1}, v_k)$ 按照所列次序而进行的松弛操作，则在所有的松弛操作之后，我们可以得到 $d[v_k]$ 的全局最短路径值。该性质与其他边的松弛操作及次序无关。

我们将归纳证明下面的性质
>在最短路径 $p$ 的第 $i$ 条边被松弛之后，$d[v_i]$ 即为 $v_i$ 的最短路径值。

$i = 0$ 时， $d[v_0] = d[s] = 0$，该值不可能再被更新。

假设第 $i-1$ 条边被松弛后，$d[v_{i - 1}]$ 为 $v_{i - 1}$ 的最短路径值。

接下来，我们将对边 $(v_{i - 1}, v_i)$ 进行松弛，由假设，$d_{i - 1}$ 保存从源节点 $s$ 到 $v_{i - 1}$ 的最短路径值，那么对边 $(v_{i - 1}, v_i)$ 进行松弛之后，$d[v_i]$ 也将更新为最短路径值。

注意到一条最短路径最多 $n - 1$ 条边，故我们只需以任意顺序所有边进行一次松弛，将上述操作进行 $n - 1$ 轮，即可得到所有节点的最短路劲。这便是 Bellman-Ford 算法。

### 3.SPFA
注意到对于边 $(u, v)$，当 $d[u]$ 被更新时，$d[v]$ 可能需要更新，而如果指向 $v$ 的所有节点都没有被更新过，那么 $v$ 一定不需要更新，借助这一点，我们可以对 Bellman-Ford 算法进行优化。

* 建立一个队列，最初队列中只含有起点 $1$。
* 取出队头节点 x，扫描它的所有出边 $(x, y, z)$，若 $d[y]> d[x] + z$，则用 $d[x] + z$ 更新 $d[y]$。同时，若 $y$ 不在队列中，则把 $y$ 入队。
* 重复上述步骤，直到队列为空。 

## 例题
### 例1. Telephone Lines(POJ 3662)
在一个 $n$ 个节点，$p$ 条边（所有边长非负）组成的无向图中，求一条 $1$ 到 $n$ 的路径，使得路径上的第 $k + 1$ 大的边权最小。
 
首先考虑如何求一条 $1$ 到 $n$ 的路径，使得该路径上的边权最大值最小。
一般的最短路问题可以表述为求一条 $1$ 到 $n$ 的路径，使得该路径上的边权之和最小。故进行松弛操作的条件时检查边权之和。
```c++
if (d[v] > d[u] + w) {
  d[v] = d[u] + w;
}
```
对于本题来说，对应的松弛操作应作如下修改：
```c++
if (d[v] > max(d[u], w)) 
  d[v] = max(d[u], w);
```

#### 解法1 分层图最短路
我们将原图扩展为 $k + 1$ 层，从上一层到下一层表示使用了一次免费机会。我们用 $(x, f)$ 表示第 $f$ 层的节点 $x$。假设本来存在着边 $(x, y)$。那么在现在的分层图中，我们将将连接节点 $(x, f)$ 和 节点 $(y, f)$，还需建立一条节点 $(x, f)$ 到 节点 $(y, f+1)$ 的，边长为 $0$ 的边，表示使用一次免费机会。
