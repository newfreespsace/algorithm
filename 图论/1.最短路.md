单源最短路径问题（Single Source Shortest Path，SSSP 问题）是指给出一张有向图，求出起点 $1$ 到其他点的最短路径。
### 1. Dijkstra 算法
>DIjkstra 仅适用于所有边的长度都是非负数的图。
1. 初始化 $dist[1] = 0$，其余节点的 $dist$ 值为正无穷大。
2. 找出节点 $x$ 满足未被标记的、且 $dist[x]$ 最小的节点，对其进行标记。
3. 遍历节点 $x$ 的所有出边 $(x, y, z)$，若 $dist[y] > dist[x] + z$，则使用 $dist[x] + z$ 更新 $dist[y]$。
4. 重复上述步骤 $2、3$，直到所有的节点都被标记。

Dijkstra 算法基于贪心思想。下面是对其的证明。
为了表述的方便，我们采用以下符号：
* $set=\{a, b, c, ...\}$ // 已经确定最短路径的点的集合，最开始集合中仅有 $1$ 号点，算法结束的时候，集合中包含所有的点。
* $dist[u]$ // 从起点开始，经过 $set$ 中的点，到 $u$ 的最短路径。
* $short[u]$ // 从起点开始，到 $u$ 的全局最短路径。

我们将证明下面这个命题：算法进行到第 $k$ 步时，$set$ 中每个节点 $i$ 的 $dist$ 值等于其 $short$ 值。第 $n$ 步时算法结束，此时已经找到起点 $1$ 到所有点的最短路径。

$k = 1$ 时，$dist[s] = short[s] = 0$  (这里 $s$ 表示起点的意思)

假设第 $k$ 步成立，即集合 set 中所有点的 $dist$ 值即为其 $short$ 值。

设第 $k + 1$ 步我们选择了顶点 $v$ (未被标记的，$dist$ 值最小的点)。现在我们想证明存在着一条更短的路径从起点到达 $v$。

假设命题不成立，注意到我们已经尝试过所有的通过集合 set 中的点到达 v 的路径，所以此时 $dist[v]$ 的值即为通过集合 $set$ 中的点到达 $v$ 的最短路径。如果存在这更短的路径的话，那么一定是经过的集合外的点，记为 $y$。所以我们有$dist[y] + d[y, v] < dist[v]$。注意到 **边长非负**，所以 $d[y, v] \ge 0$。所以 $dist[y] < dist[v]$。这与 $v$ 是未选择未标记的，$dist$ 值最小的的节点矛盾。

所以第 $k + 1$ 步也成立，我们确定了节点 $v$ 的 $short$ 值。

证明结束。

从上面的证明也可得知，算法将进行 $n$ 步。即最开始的步骤中，步骤 $2、3$ 我们将重复 $n - 1$ 次。
```c++
void dijkstra() {
  memset(d, 0x3f, sizeof d); // dist 的值初始化为正无穷大
  memset(v, 0, sizeof v);    // 所有节点最开始均未被标记
  d[1] = 0                   // 将起点放入集合 set 中
  for (int i = 1; i < n; i++) {
    int x = 0;
    for (int j = 1; j <= n; j++) 
      if (!v[j] && (x == 0 || d[j] < d[x])) x = j;
    v[x] = 1; // 将 x 放入集合 set 中，此时 d[x] 的值即为其最短路径值，步骤 2 结束
    for (int y = 1; y <= n; y++) {
      if (!v[y]) d[y] = min(d[y], d[x] + a[x][y]);
    }
  }
}
```
时间复杂度 $O(n^2)$。
改用邻接表存边 + 二叉堆维护 ``dist`` 数组，可优化算法。
```c++
void dijkstra() {
  memset(d, 0x3f, sizeof d);
  memset(v, 0, sizeof v);
  d[1] = 0;
  q.push(make_pair(0, 1));
  while (q.size()) {
    // 取出堆顶
    int x = q.top().second; q.pop();
    if (v[x]) continue;
    v[x] = 1;
    for (int i = head[x]; i; i = Next[i]) {
      int y = ver[i], z = edge[i];
      if (d[y] > d[x] + z) {
        // 更新，把新的二元组插入堆
        d[y] = d[x] + z;
        q.push(make_pair(-d[y], y));
      }
    }
  }
}
``` 
时间复杂度：
while 循环最近进行 $n$ 次，每次获取 top 的时间复杂度最多为 $\log n$。扩展边最多进行 $m$ 次，每次时间复杂度 $\log n$。故最终时间复杂度为 $(m + n)\log n$。(此处存疑，堆中的元素为 $O(n)$ 的吗？)

### 2. 松弛操作
我们用 $d[x]$ 表示从起点 $s$ 到 $x$ 的最短路径估计值。对一条边 $(u, v)$ 的松弛过程为：将从节点 $s$ 到 节点 $u$ 之间的最短路径距离加上节点 $u$ 与 $v$ 之间的边权重，并与当前的 $s$ 到 $v$ 的最短路径估计进行比较，如果前者更小，则更新估计值。
#### 初始化操作
```c++
void INITIALIZE-SINGLE-SOURCE() {
  memset(d, 0x3f, sizeof d); // d 数组为保存距离估计值的数组，其初始值为无穷大，最终值为全局最短路值
  memset(pre, 0, sizeof pre); // pre 数组用来处理最短路径，即每个节点的前驱
  d[1] = 0; // 1 号节点为起点
}
```

#### 松弛操作
```c++
void RELAX(u, v) {
  if (d[v] > d[u] + e[u][v]) {
    d[v] = d[u] + e[u][v];
    pre[v] = u;
  }
} 

对于为什么叫 ``松弛`` 这个名字，大家可以想象一条皮筋连接了起点 $s$ 到 $v$ 经过的各个节点。当我们进行了上述操作以后，皮筋相对来说可能变得更松弛一些。

### 3. Bellman-Ford 算法